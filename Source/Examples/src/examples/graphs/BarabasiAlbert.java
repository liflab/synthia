/*
    Synthia, a data structure generator
    Copyright (C) 2019-2020 Laboratoire d'informatique formelle
    Université du Québec à Chicoutimi, Canada

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package examples.graphs;

import java.util.HashSet;
import java.util.Set;

import ca.uqac.lif.synthia.random.RandomBoolean;
import ca.uqac.lif.synthia.random.RandomInteger;
import ca.uqac.lif.synthia.tree.GraphRenderer;
import ca.uqac.lif.synthia.tree.Node;
import ca.uqac.lif.synthia.util.AsInt;
import ca.uqac.lif.synthia.util.Freeze;
import ca.uqac.lif.synthia.util.Tick;
import static examples.util.Utilities.colorGradient;

/**
 * Generates a graph following the
 * <a href="https://en.wikipedia.org/wiki/Barab%C3%A1si%E2%80%93Albert_model">Barabási–Albert
 * model</a>. Such a graph is generated by first picking a number of vertices.
 * For each new vertex <i>n</i>' added to the graph, an edge is added to
 * an existing node <i>n</i> with probability <i>d<sub>n</sub></i>/<i>D</i>,
 * where <i>d<sub>n</sub></i> is the current degree of <i>n</i> and <i>D</i> is
 * the sum of the degrees of all pre-existing vertices.
 * <p>
 * The resulting graph has the property of being <em>scale-free</em>: it
 * contains few vertices with high degree, and many vertices with low degree.
 * An example of a graph generated by this program is the following:
 * <p>
 * <img src="{@docRoot}/doc-files/graphs/Graph.png" alt="Graph" />
 * <p>
 * In the source code, this graph is merely printed to the console in the DOT
 * format of the <a href="https://graphviz.org">Graphviz</a> graph rendering
 * tool. 
 * @author Sylvain Hallé
 * @ingroup Examples
 */
public class BarabasiAlbert
{
	public static void main(String[] args)
	{
		/* The pickers and data structures we need. */
		Set<Node<Integer>> nodes = new HashSet<Node<Integer>>();
		Freeze<Integer> size = new Freeze<Integer>(new RandomInteger(15, 100));
		RandomBoolean coin = new RandomBoolean();
		AsInt node_id = new AsInt(new Tick(0, 1));
		
		/* The graph starts with two connected nodes. */
		Node<Integer> start_node1 = new Node<Integer>(node_id.pick());
		Node<Integer> start_node2 = new Node<Integer>(node_id.pick());
		connect(start_node1, start_node2);
		nodes.add(start_node1);
		nodes.add(start_node2);
		
		/* Add nodes until the desired size is reached. */
		int sum_kj = 2;
		while (nodes.size() < size.pick())
		{
			Node<Integer> new_n = new Node<Integer>(node_id.pick());
			nodes.add(new_n);
			int added = 0;
			for (Node<Integer> n : nodes)
			{
				int k_i = n.getChildren().size();
				coin.setTrueProbability((float) k_i / (float) sum_kj);
				if (coin.pick())
				{
					connect(new_n, n);
					added++;
				}
			}
			sum_kj += 2 * added;
		}
		
		/* Draw. We cannot show the graph, but the following instructions render it as
		   a Graphviz input file. We tweak the default settings for a better display. */
		float max_degree = getMaxDegree(nodes);
		GraphRenderer<Integer> gr = new GraphRenderer<Integer>(false) {
			public String getLabel(Node<Integer> n) { return ""; }
			public String getColor(Node<Integer> n) { return colorGradient((float) n.getChildren().size() / max_degree); }
		}.setNodeString("[style=\"filled\",width=0.1,height=0.1,shape=\"circle\"]");
		gr.printToDot(System.out, start_node1);
	}
	
	/**
	 * Connects two nodes in a graph.
	 * @param n1 The first node
	 * @param n2 The second node
	 */
	protected static void connect(Node<Integer> n1, Node<Integer> n2)
	{
		n1.addChild(n2);
		n2.addChild(n1);
	}
	
	/**
	 * Gets the maximum out degree in a set of nodes.
	 * @param nodes The set of nodes
	 * @return The maximum out degree
	 */
	protected static int getMaxDegree(Set<Node<Integer>> nodes)
	{
		int max = 0;
		for (Node<Integer> n : nodes)
		{
			max = Math.max(max, n.getChildren().size());
		}
		return max;
	}
}
